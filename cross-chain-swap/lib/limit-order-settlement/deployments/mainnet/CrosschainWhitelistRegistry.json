{
  "address": "0xBe89346fE1cE1367f3d80C8522209A86511B1201",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract WhitelistRegistry",
          "name": "_whitelistRegistry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ETHTransferFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeTransferFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SamePromotee",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "promoter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "promotee",
          "type": "address"
        }
      ],
      "name": "Promotion",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        }
      ],
      "name": "getPromotees",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "promotees",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "promotee",
          "type": "address"
        }
      ],
      "name": "promote",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "promoter",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        }
      ],
      "name": "promotions",
      "outputs": [
        {
          "internalType": "address",
          "name": "promotee",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "rescueFunds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "whitelistRegistry",
      "outputs": [
        {
          "internalType": "contract WhitelistRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x013b8367444e6e75e9d1369ec657b1d9acb55bbef71dc5286b34f365f80e9dac",
  "receipt": {
    "to": null,
    "from": "0x11799622F4D98A24514011E8527B969f7488eF47",
    "contractAddress": "0xBe89346fE1cE1367f3d80C8522209A86511B1201",
    "transactionIndex": 61,
    "gasUsed": "616533",
    "logsBloom": "0x00000100000000000000000000000000000000000000000000800000000800000000000000020000000000000000000000000000000000000000000000000000000000000080000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000010000000000000000000000000",
    "blockHash": "0x2f330cc7ae656cd05f5aa376dd22699af20056a54ed2820f82a676f67e2e4c2f",
    "transactionHash": "0x013b8367444e6e75e9d1369ec657b1d9acb55bbef71dc5286b34f365f80e9dac",
    "logs": [
      {
        "transactionIndex": 61,
        "blockNumber": 20619580,
        "transactionHash": "0x013b8367444e6e75e9d1369ec657b1d9acb55bbef71dc5286b34f365f80e9dac",
        "address": "0xBe89346fE1cE1367f3d80C8522209A86511B1201",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000011799622f4d98a24514011e8527b969f7488ef47"
        ],
        "data": "0x",
        "logIndex": 390,
        "blockHash": "0x2f330cc7ae656cd05f5aa376dd22699af20056a54ed2820f82a676f67e2e4c2f"
      }
    ],
    "blockNumber": 20619580,
    "cumulativeGasUsed": "12262679",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xF55684BC536487394B423e70567413faB8e45E26"
  ],
  "numDeployments": 1,
  "solcInputHash": "bfcd11c1b234bc6d7311fe0c031f04e2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract WhitelistRegistry\",\"name\":\"_whitelistRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ETHTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SamePromotee\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"promoter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"promotee\",\"type\":\"address\"}],\"name\":\"Promotion\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getPromotees\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"promotees\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"promotee\",\"type\":\"address\"}],\"name\":\"promote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"promotions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"promotee\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistRegistry\",\"outputs\":[{\"internalType\":\"contract WhitelistRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"getPromotees(uint256)\":{\"params\":{\"chainId\":\"The chain ID to get the promoted addresses for.\"},\"returns\":{\"promotees\":\"A list of worker addresses.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"promote(uint256,address)\":{\"params\":{\"chainId\":\"The chain ID where the worker will assigned.\",\"promotee\":\"The worker's address.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"rescueFunds(address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens to recover.\",\"token_\":\"The token to recover.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"CrosschainWhitelistRegistry\",\"version\":1},\"userdoc\":{\"events\":{\"Promotion(address,uint256,address)\":{\"notice\":\"Emitted when a new worker for a resolver is set.\"}},\"kind\":\"user\",\"methods\":{\"getPromotees(uint256)\":{\"notice\":\"Returns the worker list for a particular chain ID.\"},\"promote(uint256,address)\":{\"notice\":\"Registers a worker for the resolver to settle orders.\"},\"rescueFunds(address,uint256)\":{\"notice\":\"Allows the contract owner to recover any tokens accidentally sent to the contract.\"}},\"notice\":\"The contract manages a promotees for crosschain resolvers. It also includes an emergency rescue function for tokens sent to the contract accidentally.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/CrosschainWhitelistRegistry.sol\":\"CrosschainWhitelistRegistry\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDaiLikePermit\\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\\n */\\ninterface IDaiLikePermit {\\n    /**\\n     * @notice Approves spending of tokens via off-chain signatures.\\n     * @param holder Token holder's address.\\n     * @param spender Spender's address.\\n     * @param nonce Current nonce of the holder.\\n     * @param expiry Time when the permit expires.\\n     * @param allowed True to allow, false to disallow spending.\\n     * @param v, r, s Signature components.\\n     */\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xf8636c1c4631641c7b40ac65cd69e6ae04a99cf3358426c642dec02c6c774c82\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IERC20MetadataUppercase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC20MetadataUppercase\\n * @dev Interface for ERC20 token metadata with uppercase naming convention.\\n */\\ninterface IERC20MetadataUppercase {\\n    /**\\n     * @notice Gets the token name.\\n     * @return Token name.\\n     */\\n    function NAME() external view returns (string memory); // solhint-disable-line func-name-mixedcase\\n\\n    /**\\n     * @notice Gets the token symbol.\\n     * @return Token symbol.\\n     */\\n    function SYMBOL() external view returns (string memory); // solhint-disable-line func-name-mixedcase\\n}\\n\",\"keccak256\":\"0x7d97ae2903bd1ee8f24ab7bbf099d075f2bbd451b0f755366479d249780d0c68\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC7597Permit\\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\\n */\\ninterface IERC7597Permit {\\n    /**\\n     * @notice Update allowance with a signed permit.\\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\\n     * @param owner Token owner's address (Authorizer).\\n     * @param spender Spender's address.\\n     * @param value Amount of allowance.\\n     * @param deadline The time at which the signature expires (unixtime).\\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) external;\\n}\\n\",\"keccak256\":\"0xaf148ecd4db0f44989a7417f6945bcfd18273c5096bc2b364e314e42c85c78cd\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPermit2\\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\\n */\\ninterface IPermit2 {\\n    /**\\n     * @dev Struct for holding permit details.\\n     * @param token ERC20 token address for which the permit is issued.\\n     * @param amount The maximum amount allowed to spend.\\n     * @param expiration Timestamp until which the permit is valid.\\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\\n     */\\n    struct PermitDetails {\\n        address token;\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @dev Struct for a single token allowance permit.\\n     * @param details Permit details including token, amount, expiration, and nonce.\\n     * @param spender Address authorized to spend the tokens.\\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\\n     */\\n    struct PermitSingle {\\n        PermitDetails details;\\n        address spender;\\n        uint256 sigDeadline;\\n    }\\n\\n    /**\\n     * @dev Struct for packed allowance data to optimize storage.\\n     * @param amount Amount allowed.\\n     * @param expiration Permission expiry timestamp.\\n     * @param nonce Unique incrementing value for tracking allowances.\\n     */\\n    struct PackedAllowance {\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @notice Executes a token transfer from one address to another.\\n     * @param user The token owner's address.\\n     * @param spender The address authorized to spend the tokens.\\n     * @param amount The amount of tokens to transfer.\\n     * @param token The address of the token being transferred.\\n     */\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    /**\\n     * @notice Issues a permit for spending tokens via a signed authorization.\\n     * @param owner The token owner's address.\\n     * @param permitSingle Struct containing the permit details.\\n     * @param signature The signature proving the owner authorized the permit.\\n     */\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /**\\n     * @notice Retrieves the allowance details between a token owner and spender.\\n     * @param user The token owner's address.\\n     * @param token The token address.\\n     * @param spender The spender's address.\\n     * @return The packed allowance details.\\n     */\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n}\\n\",\"keccak256\":\"0x0e8375c63b72926e9073c5712fd6a181dce58ee155d73c57e34febace7949bfa\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IWETH\\n * @dev Interface for wrapper as WETH-like token.\\n */\\ninterface IWETH is IERC20 {\\n    /**\\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\\n     */\\n    event Deposit(address indexed dst, uint256 wad);\\n\\n    /**\\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\\n     */\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    /**\\n     * @notice Deposit Ether to get wrapper tokens.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Withdraw wrapped tokens as Ether.\\n     * @param amount Amount of wrapped tokens to withdraw.\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x32989b79850e8a1ac6aab74878de2883f9537656ca06910dc0ae76833cc446e2\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/AddressArray.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title AddressArray\\n * @notice Implements a dynamic array of addresses using a mapping for storage efficiency, with the array length stored at index 0.\\n * @dev This library provides basic functionalities such as push, pop, set, and retrieval of addresses in a storage-efficient manner.\\n */\\nlibrary AddressArray {\\n    /**\\n     * @dev Error thrown when attempting to access an index outside the bounds of the array.\\n     */\\n    error IndexOutOfBounds();\\n\\n    /**\\n     * @dev Error thrown when attempting to pop an element from an empty array.\\n     */\\n    error PopFromEmptyArray();\\n\\n    /**\\n     * @dev Error thrown when the output array provided for getting the list of addresses is too small.\\n     */\\n    error OutputArrayTooSmall();\\n\\n    uint256 internal constant _ZERO_ADDRESS = 0x8000000000000000000000000000000000000000000000000000000000000000; // Next tx gas optimization\\n    uint256 internal constant _LENGTH_MASK  = 0x0000000000000000ffffffff0000000000000000000000000000000000000000;\\n    uint256 internal constant _ADDRESS_MASK = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\\n    uint256 internal constant _ONE_LENGTH   = 0x0000000000000000000000010000000000000000000000000000000000000000;\\n    uint256 internal constant _LENGTH_OFFSET = 160;\\n\\n    /**\\n     * @dev Struct containing the raw mapping used to store the addresses and the array length.\\n     */\\n    struct Data {\\n        uint256[1 << 32] _raw;\\n    }\\n\\n    /**\\n     * @notice Returns the number of addresses stored in the array.\\n     * @param self The instance of the Data struct.\\n     * @return The number of addresses.\\n     */\\n    function length(Data storage self) internal view returns (uint256) {\\n        return (self._raw[0] & _LENGTH_MASK) >> _LENGTH_OFFSET;\\n    }\\n\\n    /**\\n     * @notice Retrieves the address at a specified index in the array.\\n     * @param self The instance of the Data struct.\\n     * @param i The index to retrieve the address from.\\n     * @return The address stored at the specified index.\\n     */\\n    function at(Data storage self, uint256 i) internal view returns (address) {\\n        if (i >= 1 << 32) revert IndexOutOfBounds();\\n        return address(uint160(self._raw[i] & _ADDRESS_MASK));\\n    }\\n\\n    /**\\n     * @notice Returns all addresses in the array from storage.\\n     * @param self The instance of the Data struct.\\n     * @return output Array containing all the addresses.\\n     */\\n    function get(Data storage self) internal view returns (address[] memory output) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let lengthAndFirst := sload(self.slot)\\n            let len := shr(_LENGTH_OFFSET, and(lengthAndFirst, _LENGTH_MASK))\\n            let fst := and(lengthAndFirst, _ADDRESS_MASK)\\n\\n            // Allocate array\\n            output := mload(0x40)\\n            mstore(0x40, add(output, mul(0x20, add(1, len))))\\n            mstore(output, len)\\n\\n            if len {\\n                // Copy first element and then the rest in a loop\\n                let ptr := add(output, 0x20)\\n                mstore(ptr, fst)\\n                for { let i := 1 } lt(i, len) { i:= add(i, 1) } {\\n                    let item := and(sload(add(self.slot, i)), _ADDRESS_MASK)\\n                    mstore(add(ptr, mul(0x20, i)), item)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Copies the addresses into the provided output array.\\n     * @param self The instance of the Data struct.\\n     * @param input The array to copy the addresses into.\\n     * @return output The provided output array filled with addresses.\\n     */\\n    function get(Data storage self, address[] memory input) internal view returns (address[] memory output) {\\n        output = input;\\n        bytes4 err = OutputArrayTooSmall.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let lengthAndFirst := sload(self.slot)\\n            let len := shr(_LENGTH_OFFSET, and(lengthAndFirst, _LENGTH_MASK))\\n            let fst := and(lengthAndFirst, _ADDRESS_MASK)\\n\\n            if gt(len, mload(input)) {\\n                mstore(0, err)\\n                revert(0, 4)\\n            }\\n            if len {\\n                // Copy first element and then the rest in a loop\\n                let ptr := add(output, 0x20)\\n                mstore(ptr, fst)\\n                for { let i := 1 } lt(i, len) { i:= add(i, 1) } {\\n                    let item := and(sload(add(self.slot, i)), _ADDRESS_MASK)\\n                    mstore(add(ptr, mul(0x20, i)), item)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds an address to the end of the array.\\n     * @param self The instance of the Data struct.\\n     * @param account The address to add.\\n     * @return res The new length of the array.\\n     */\\n    function push(Data storage self, address account) internal returns (uint256 res) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let lengthAndFirst := sload(self.slot)\\n            let len := shr(_LENGTH_OFFSET, and(lengthAndFirst, _LENGTH_MASK))\\n\\n            switch len\\n            case 0 {\\n                sstore(self.slot, or(account, _ONE_LENGTH))\\n            }\\n            default {\\n                sstore(self.slot, add(lengthAndFirst, _ONE_LENGTH))\\n                sstore(add(self.slot, len), or(account, _ZERO_ADDRESS))\\n            }\\n            res := add(len, 1)\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes the last address from the array.\\n     * @param self The instance of the Data struct.\\n     */\\n    function pop(Data storage self) internal {\\n        bytes4 err = PopFromEmptyArray.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let lengthAndFirst := sload(self.slot)\\n            let len := shr(_LENGTH_OFFSET, and(lengthAndFirst, _LENGTH_MASK))\\n\\n            switch len\\n            case 0 {\\n                mstore(0, err)\\n                revert(0, 4)\\n            }\\n            case 1 {\\n                sstore(self.slot, _ZERO_ADDRESS)\\n            }\\n            default {\\n                sstore(self.slot, sub(lengthAndFirst, _ONE_LENGTH))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Array pop back operation for storage `self` that returns popped element.\\n     * @param self The instance of the Data struct.\\n     * @return res The address that was removed from the array.\\n     */\\n    function popGet(Data storage self) internal returns(address res) {\\n        bytes4 err = PopFromEmptyArray.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let lengthAndFirst := sload(self.slot)\\n            let len := shr(_LENGTH_OFFSET, and(lengthAndFirst, _LENGTH_MASK))\\n\\n            switch len\\n            case 0 {\\n                mstore(0, err)\\n                revert(0, 4)\\n            }\\n            case 1 {\\n                res := and(lengthAndFirst, _ADDRESS_MASK)\\n                sstore(self.slot, _ZERO_ADDRESS)\\n            }\\n            default {\\n                res := and(sload(add(self.slot, sub(len, 1))), _ADDRESS_MASK)\\n                sstore(self.slot, sub(lengthAndFirst, _ONE_LENGTH))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the address at a specified index in the array.\\n     * @param self The instance of the Data struct.\\n     * @param index The index at which to set the address.\\n     * @param account The address to set at the specified index.\\n     */\\n    function set(Data storage self, uint256 index, address account) internal {\\n        bytes4 err = IndexOutOfBounds.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let lengthAndFirst := sload(self.slot)\\n            let len := shr(_LENGTH_OFFSET, and(lengthAndFirst, _LENGTH_MASK))\\n            let fst := and(lengthAndFirst, _ADDRESS_MASK)\\n\\n            if iszero(lt(index, len)) {\\n                mstore(0, err)\\n                revert(0, 4)\\n            }\\n\\n            switch index\\n            case 0 {\\n                sstore(self.slot, or(xor(lengthAndFirst, fst), account))\\n            }\\n            default {\\n                sstore(add(self.slot, index), or(account, _ZERO_ADDRESS))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Erase length of the array.\\n     * @param self The instance of the Data struct.\\n     */\\n    function erase(Data storage self) internal {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            sstore(self.slot, _ADDRESS_MASK)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x37ff5d5e48795347ab12f83945d9dc7c18b2bce15677bbacc1154a7dc1a6a981\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressArray.sol\\\";\\n\\n/**\\n * @title AddressSet\\n * @notice Library for managing sets of addresses, allowing operations such as add, remove, and contains.\\n * Utilizes the AddressArray library for underlying data storage.\\n */\\nlibrary AddressSet {\\n    using AddressArray for AddressArray.Data;\\n\\n    uint256 internal constant _NULL_INDEX = type(uint256).max;\\n\\n    /**\\n     * @dev Data struct from AddressArray.Data items\\n     * and lookup mapping address => index in data array.\\n     */\\n    struct Data {\\n        AddressArray.Data items;\\n        mapping(address => uint256) lookup;\\n    }\\n\\n    /**\\n     * @notice Determines the number of addresses in the set.\\n     * @param s The set of addresses.\\n     * @return The number of addresses in the set.\\n     */\\n    function length(Data storage s) internal view returns (uint256) {\\n        return s.items.length();\\n    }\\n\\n    /**\\n     * @notice Retrieves the address at a specified index in the set.\\n     * @param s The set of addresses.\\n     * @param index The index of the address to retrieve.\\n     * @return The address at the specified index.\\n     */\\n    function at(Data storage s, uint256 index) internal view returns (address) {\\n        return s.items.at(index);\\n    }\\n\\n    /**\\n     * @notice Checks if the set contains the specified address.\\n     * @param s The set of addresses.\\n     * @param item The address to check for.\\n     * @return True if the set contains the address, false otherwise.\\n     */\\n    function contains(Data storage s, address item) internal view returns (bool) {\\n        uint256 index = s.lookup[item];\\n        return index != 0 && index != _NULL_INDEX;\\n    }\\n\\n    /**\\n     * @notice Returns list of addresses from storage `s`.\\n     * @param s The set of addresses.\\n     * @return The array of addresses stored in `s`.\\n     */\\n    function get(Data storage s) internal view returns (address[] memory) {\\n        return s.items.get();\\n    }\\n\\n    /**\\n     * @notice Puts list of addresses from `s` storage into `output` array.\\n     * @param s The set of addresses.\\n     * @return The provided output array filled with addresses.\\n     */\\n    function get(Data storage s, address[] memory input) internal view returns (address[] memory) {\\n        return s.items.get(input);\\n    }\\n\\n    /**\\n     * @notice Adds an address to the set if it is not already present.\\n     * @param s The set of addresses.\\n     * @param item The address to add.\\n     * @return True if the address was added to the set, false if it was already present.\\n     */\\n    function add(Data storage s, address item) internal returns (bool) {\\n        uint256 index = s.lookup[item];\\n        if (index != 0 && index != _NULL_INDEX) {\\n            return false;\\n        }\\n        s.lookup[item] = s.items.push(item);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Removes an address from the set if it exists.\\n     * @param s The set of addresses.\\n     * @param item The address to remove.\\n     * @return True if the address was removed from the set, false if it was not found.\\n     */\\n    function remove(Data storage s, address item) internal returns (bool) {\\n        uint256 index = s.lookup[item];\\n        s.lookup[item] = _NULL_INDEX;\\n        if (index == 0 || index == _NULL_INDEX) {\\n            return false;\\n        }\\n\\n        address lastItem = s.items.popGet();\\n        if (lastItem != item) {\\n            unchecked {\\n                s.items.set(index - 1, lastItem);\\n                s.lookup[lastItem] = index;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Erases set from storage `s`.\\n     * @param s The set of addresses.\\n     * @return items All removed items.\\n     */\\n    function erase(Data storage s) internal returns(address[] memory items) {\\n        items = s.items.get();\\n        uint256 len = items.length;\\n        if (len > 0) {\\n            s.items.erase();\\n            unchecked {\\n                for (uint256 i = 0; i < len; i++) {\\n                    s.lookup[items[i]] = _NULL_INDEX;\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd177ddfd16a5bb8fc969538e5aa93fc49f464a298faa53c6c91dc691711d50fc\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RevertReasonForwarder\\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\\n */\\nlibrary RevertReasonForwarder {\\n    /**\\n     * @dev Forwards the revert reason from the latest external call.\\n     * This method allows propagating the revert reason of a failed external call to the caller.\\n     */\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the revert reason from the latest external call.\\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\\n     * @return reason The latest external call revert reason.\\n     */\\n    function reReason() internal pure returns (bytes memory reason) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            reason := mload(0x40)\\n            let length := returndatasize()\\n            mstore(reason, length)\\n            returndatacopy(add(reason, 0x20), 0, length)\\n            mstore(0x40, add(reason, add(0x20, length)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x97d8c950981f4da44ae1b01d9e597c4f99377797ec7ff7b1ef9648e4ecc1baa4\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IERC7597Permit.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/**\\n * @title Implements efficient safe methods for ERC20 interface.\\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\\n * 1. more gas-efficient, providing significant savings in transaction costs.\\n * 2. support for different permit implementations\\n * 3. forceApprove functionality\\n * 4. support for WETH deposit and withdraw\\n */\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    // Uniswap Permit2 address\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\\n\\n    /**\\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\\n     * Consumes less gas then regular `ERC20.balanceOf`.\\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\\n     * @param token The IERC20 token contract for which the balance will be fetched.\\n     * @param account The address of the account whose token balance will be fetched.\\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\\n     */\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another.\\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\\n     */\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(_PERMIT2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens to another address.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely increases the allowance of a spender.\\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to increase the allowance by.\\n     */\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /**\\n     * @notice Safely decreases the allowance of a spender.\\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to decrease the allowance by.\\n     */\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param owner The owner of the tokens for which the permit is made.\\n     * @param spender The spender allowed to spend the tokens by the permit.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\\n     */\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    /**\\n     * @notice The function attempts to call the permit function on a given ERC20 token.\\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\\n     * It accommodates both Compact and Full formats of these permit types.\\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\\n     * before invocation for optimized performance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The address of the ERC20 token on which to call the permit function.\\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\\n     * @param spender The address which will be approved for transfer of tokens.\\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\\n     * @return success A boolean indicating whether the permit call was successful.\\n     */\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        // load function selectors for different permit standards\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // Switch case for different permit lengths, indicating different permit standards\\n            switch permit.length\\n            // Compact IERC20Permit\\n            case 100 {\\n                mstore(ptr, permitSelector)     // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // Compact IDaiLikePermit\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)  // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // IERC20Permit\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // IDaiLikePermit\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // Compact IPermit2\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)  // store selector\\n                mstore(add(ptr, 0x04), owner) // store owner\\n                mstore(add(ptr, 0x24), token) // store token\\n\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\\n                mstore(add(ptr, 0xa4), spender)                               // store spender\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // IPermit2\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // Dynamic length\\n            default {\\n                mstore(ptr, erc7597PermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param selector The function signature that is to be called on the token contract.\\n     * @param to The address to which the token amount will be transferred.\\n     * @param amount The token amount to be transferred.\\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\\n     * In case of success but no returned data, validates that the contract code exists.\\n     * In case of returned data, ensures that it's a boolean `true`.\\n     */\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of Ether to deposit into the IWETH contract.\\n     */\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        if (amount > 0) {\\n            bytes4 selector = IWETH.deposit.selector;\\n            assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                mstore(0, selector)\\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\\n     * @dev Uses inline assembly to interact with the IWETH contract.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     */\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\\n     * Consumes less gas then regular `IWETH.withdraw`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     * @param to The recipient of the withdrawn Ether.\\n     */\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf5010526a91c8fe876a0959e952186156a0c8f1888bf392eb406a93f449b2716\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/StringUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title StringUtil\\n * @dev Library with gas-efficient string operations.\\n */\\nlibrary StringUtil {\\n    /**\\n     * @notice Converts a uint256 value to its hexadecimal string representation.\\n     * @param value The uint256 value to convert.\\n     * @return The hexadecimal string representation of the input value.\\n     */\\n    function toHex(uint256 value) internal pure returns (string memory) {\\n        return toHex(abi.encodePacked(value));\\n    }\\n\\n    /**\\n     * @notice Converts an address to its hexadecimal string representation.\\n     * @param value The address to convert.\\n     * @return The hexadecimal string representation of the input address.\\n     */\\n    function toHex(address value) internal pure returns (string memory) {\\n        return toHex(abi.encodePacked(value));\\n    }\\n\\n    /**\\n     * @dev Converts arbitrary bytes to their hexadecimal string representation.\\n     * This is an assembly adaptation of highly optimized toHex16 code by Mikhail Vladimirov.\\n     * Reference: https://stackoverflow.com/a/69266989\\n     * @param data The bytes to be converted to hexadecimal string.\\n     * @return result The hexadecimal string representation of the input bytes.\\n     */\\n    function toHex(bytes memory data) internal pure returns (string memory result) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            function _toHex16(input) -> output {\\n                output := or(\\n                    and(input, 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000),\\n                    shr(64, and(input, 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000))\\n                )\\n                output := or(\\n                    and(output, 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000),\\n                    shr(32, and(output, 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000))\\n                )\\n                output := or(\\n                    and(output, 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000),\\n                    shr(16, and(output, 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000))\\n                )\\n                output := or(\\n                    and(output, 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000),\\n                    shr(8, and(output, 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000))\\n                )\\n                output := or(\\n                    shr(4, and(output, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\\n                    shr(8, and(output, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\\n                )\\n                output := add(\\n                    add(0x3030303030303030303030303030303030303030303030303030303030303030, output),\\n                    mul(\\n                        and(\\n                            shr(4, add(output, 0x0606060606060606060606060606060606060606060606060606060606060606)),\\n                            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\\n                        ),\\n                        7 // Change 7 to 39 for lower case output\\n                    )\\n                )\\n            }\\n\\n            result := mload(0x40)\\n            let length := mload(data)\\n            let resultLength := shl(1, length)\\n            let toPtr := add(result, 0x22) // 32 bytes for length + 2 bytes for '0x'\\n            mstore(0x40, add(toPtr, resultLength)) // move free memory pointer\\n            mstore(add(result, 2), 0x3078) // 0x3078 is right aligned so we write to `result + 2`\\n            // to store the last 2 bytes in the beginning of the string\\n            mstore(result, add(resultLength, 2)) // extra 2 bytes for '0x'\\n\\n            for {\\n                let fromPtr := add(data, 0x20)\\n                let endPtr := add(fromPtr, length)\\n            } lt(fromPtr, endPtr) {\\n                fromPtr := add(fromPtr, 0x20)\\n            } {\\n                let rawData := mload(fromPtr)\\n                let hexData := _toHex16(rawData)\\n                mstore(toPtr, hexData)\\n                toPtr := add(toPtr, 0x20)\\n                hexData := _toHex16(shl(128, rawData))\\n                mstore(toPtr, hexData)\\n                toPtr := add(toPtr, 0x20)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb05bff1a3a5461b1f16248220067a2bd52e5c7e41c14be0aebb6520985b67ccb\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"../interfaces/IERC20MetadataUppercase.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./StringUtil.sol\\\";\\n\\n/**\\n * @title UniERC20\\n * @dev Library to abstract the handling of ETH and ERC20 tokens, enabling unified interaction with both. It allows usage of ETH as ERC20.\\n * Utilizes SafeERC20 for ERC20 interactions and provides additional utility functions.\\n */\\nlibrary UniERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    error InsufficientBalance();\\n    error ApproveCalledOnETH();\\n    error NotEnoughValue();\\n    error FromIsNotSender();\\n    error ToIsNotThis();\\n    error ETHTransferFailed();\\n\\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\\n\\n    /**\\n     * @dev Determines if the specified token is ETH.\\n     * @param token The token to check.\\n     * @return bool True if the token is ETH, false otherwise.\\n     */\\n    function isETH(IERC20 token) internal pure returns (bool) {\\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of the specified token for an account.\\n     * @param token The token to query the balance of.\\n     * @param account The address of the account.\\n     * @return uint256 The balance of the token for the specified account.\\n     */\\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\\n        if (isETH(token)) {\\n            return account.balance;\\n        } else {\\n            return token.balanceOf(account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a specified amount of the token to a given address.\\n     * Note: Does nothing if the amount is zero.\\n     * @param token The token to transfer.\\n     * @param to The address to transfer the token to.\\n     * @param amount The amount of the token to transfer.\\n     */\\n    function uniTransfer(\\n        IERC20 token,\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            if (isETH(token)) {\\n                if (address(this).balance < amount) revert InsufficientBalance();\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (bool success, ) = to.call{value: amount, gas: _RAW_CALL_GAS_LIMIT}(\\\"\\\");\\n                if (!success) revert ETHTransferFailed();\\n            } else {\\n                token.safeTransfer(to, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a specified amount of the token from one address to another.\\n     * Note: Does nothing if the amount is zero.\\n     * @param token The token to transfer.\\n     * @param from The address to transfer the token from.\\n     * @param to The address to transfer the token to.\\n     * @param amount The amount of the token to transfer.\\n     */\\n    function uniTransferFrom(\\n        IERC20 token,\\n        address payable from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            if (isETH(token)) {\\n                if (msg.value < amount) revert NotEnoughValue();\\n                if (from != msg.sender) revert FromIsNotSender();\\n                if (to != address(this)) revert ToIsNotThis();\\n                if (msg.value > amount) {\\n                    // Return remainder if exist\\n                    unchecked {\\n                        // solhint-disable-next-line avoid-low-level-calls\\n                        (bool success, ) = from.call{value: msg.value - amount, gas: _RAW_CALL_GAS_LIMIT}(\\\"\\\");\\n                        if (!success) revert ETHTransferFailed();\\n                    }\\n                }\\n            } else {\\n                token.safeTransferFrom(from, to, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the symbol from ERC20 metadata of the specified token.\\n     * @param token The token to retrieve the symbol of.\\n     * @return string The symbol of the token.\\n     */\\n    function uniSymbol(IERC20 token) internal view returns (string memory) {\\n        return _uniDecode(token, IERC20Metadata.symbol.selector, IERC20MetadataUppercase.SYMBOL.selector);\\n    }\\n\\n    /**\\n     * @dev Retrieves the name from ERC20 metadata of the specified token.\\n     * @param token The token to retrieve the name of.\\n     * @return string The name of the token.\\n     */\\n    function uniName(IERC20 token) internal view returns (string memory) {\\n        return _uniDecode(token, IERC20Metadata.name.selector, IERC20MetadataUppercase.NAME.selector);\\n    }\\n\\n    /**\\n     * @dev forceApprove the specified amount of the token to a given address.\\n     * Reverts if the token is ETH.\\n     * @param token The token to approve.\\n     * @param to The address to approve the token to.\\n     * @param amount The amount of the token to approve.\\n     */\\n    function uniApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (isETH(token)) revert ApproveCalledOnETH();\\n\\n        token.forceApprove(to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to decode token metadata (name or symbol).\\n     * 20K gas is provided to account for possible implementations of name/symbol\\n     * (token implementation might be behind proxy or store the value in storage)\\n     * @param token The token to decode metadata for.\\n     * @param lowerCaseSelector The selector for the lowercase metadata function.\\n     * @param upperCaseSelector The selector for the uppercase metadata function.\\n     * @return result The decoded metadata value.\\n     */\\n    function _uniDecode(\\n        IERC20 token,\\n        bytes4 lowerCaseSelector,\\n        bytes4 upperCaseSelector\\n    ) private view returns (string memory result) {\\n        if (isETH(token)) {\\n            return \\\"ETH\\\";\\n        }\\n\\n        (bool success, bytes memory data) = address(token).staticcall{gas: 20000}(\\n            abi.encodeWithSelector(lowerCaseSelector)\\n        );\\n        if (!success) {\\n            (success, data) = address(token).staticcall{gas: 20000}(abi.encodeWithSelector(upperCaseSelector));\\n        }\\n\\n        if (success && data.length >= 0x40) {\\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\\n            /*\\n                return data is padded up to 32 bytes with ABI encoder also sometimes\\n                there is extra 32 bytes of zeros padded in the end:\\n                https://github.com/ethereum/solidity/issues/10170\\n                because of that we can't check for equality and instead check\\n                that overall data length is greater or equal than string length + extra 64 bytes\\n            */\\n            if (offset == 0x20 && data.length >= 0x40 + len) {\\n                assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                    result := add(data, 0x40)\\n                }\\n                return result;\\n            }\\n        }\\n        if (success && data.length == 32) {\\n            uint256 len = 0;\\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\\n                unchecked {\\n                    len++;\\n                }\\n            }\\n\\n            if (len > 0) {\\n                assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                    mstore(data, len)\\n                }\\n                return string(data);\\n            }\\n        }\\n\\n        return StringUtil.toHex(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xcdd6c93b823011a47bc3655148bdec951217cfd4b99299249a83a3cce12f1f12\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaa761817f6cd7892fcf158b3c776b34551cde36f48ff9703d53898bc45a94ea2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x6008dabfe393240d73d7dd7688033f72740d570aa422254d29a7dce8568f3aff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/CrosschainWhitelistRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { UniERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\\\";\\nimport { WhitelistRegistry } from \\\"./WhitelistRegistry.sol\\\";\\n\\n/**\\n * @title CrosschainWhitelistRegistry\\n * @notice The contract manages a promotees for crosschain resolvers. It also includes an\\n * emergency rescue function for tokens sent to the contract accidentally.\\n */\\ncontract CrosschainWhitelistRegistry is Ownable {\\n    using UniERC20 for IERC20;\\n\\n    error SamePromotee();\\n\\n    /// @notice Emitted when a new worker for a resolver is set.\\n    event Promotion(address promoter, uint256 chainId, address promotee);\\n\\n    mapping(address promoter => mapping(uint256 chainId => address promotee)) public promotions;\\n\\n    WhitelistRegistry public whitelistRegistry;\\n\\n    constructor(WhitelistRegistry _whitelistRegistry) Ownable(msg.sender) {\\n        whitelistRegistry = _whitelistRegistry;\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to recover any tokens accidentally sent to the contract.\\n     * @param token_ The token to recover.\\n     * @param amount The amount of tokens to recover.\\n     */\\n    function rescueFunds(IERC20 token_, uint256 amount) external onlyOwner {\\n        token_.uniTransfer(payable(msg.sender), amount);\\n    }\\n\\n    /**\\n     * @notice Registers a worker for the resolver to settle orders.\\n     * @param chainId The chain ID where the worker will assigned.\\n     * @param promotee The worker's address.\\n     */\\n    function promote(uint256 chainId, address promotee) external {\\n        if (promotions[msg.sender][chainId] == promotee) revert SamePromotee();\\n        promotions[msg.sender][chainId] = promotee;\\n        emit Promotion(msg.sender, chainId, promotee);\\n    }\\n\\n    /**\\n     * @notice Returns the worker list for a particular chain ID.\\n     * @param chainId The chain ID to get the promoted addresses for.\\n     * @return promotees A list of worker addresses.\\n     */\\n    function getPromotees(uint256 chainId) external view returns (address[] memory promotees) {\\n        promotees = whitelistRegistry.getWhitelist();\\n        unchecked {\\n            uint256 len = promotees.length;\\n            for (uint256 i = 0; i < len; ++i) {\\n                promotees[i] = promotions[promotees[i]][chainId];\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf2cccc5f910b9bbf8d841ce811635417c594b2af5d09367c5f64b44404330e78\",\"license\":\"MIT\"},\"contracts/WhitelistRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { UniERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\\\";\\nimport { AddressSet, AddressArray } from \\\"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\\\";\\n\\n/**\\n * @title WhitelistRegistry\\n * @notice The contract manages a whitelist for trading resolvers, providing functions to register,\\n * promote and remove addresses, as well as setting various thresholds and limits. It also includes an\\n * emergency rescue function for tokens sent to the contract accidentally.\\n */\\ncontract WhitelistRegistry is Ownable {\\n    using UniERC20 for IERC20;\\n    using AddressSet for AddressSet.Data;\\n    using AddressArray for AddressArray.Data;\\n\\n    error BalanceLessThanThreshold();\\n    error AlreadyRegistered();\\n    error SamePromotee();\\n    error InvalidThreshold();\\n\\n    /// @notice Emitted after a new resolver is registered.\\n    event Registered(address addr);\\n    /// @notice Emitted when a resolver is pushed out of whitelist.\\n    event Unregistered(address addr);\\n    /// @notice Emitted when the new minimum total supply percentage to get into the whitelist is set.\\n    event ResolverPercentageThresholdSet(uint256 resolverPercentageThreshold);\\n    /// @notice Emitted when a new worker for a resolver is set.\\n    event Promotion(address promoter, uint256 chainId, address promotee);\\n\\n    uint256 public constant BASIS_POINTS = 10000;\\n    IERC20 public immutable TOKEN;\\n\\n    mapping(address promoter => mapping(uint256 chainId => address promotee)) public promotions;\\n    // 100% = 10000, 10% = 1000, 1% = 100\\n    uint256 public resolverPercentageThreshold;\\n\\n    AddressSet.Data private _whitelist;\\n\\n    constructor(\\n        IERC20 token_,\\n        uint256 resolverPercentageThreshold_\\n    ) Ownable(msg.sender) {\\n        TOKEN = token_;\\n        _setResolverPercentageThreshold(resolverPercentageThreshold_);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to recover any tokens accidentally sent to the contract.\\n     * @param token_ The token to recover.\\n     * @param amount The amount of tokens to recover.\\n     */\\n    function rescueFunds(IERC20 token_, uint256 amount) external onlyOwner {\\n        token_.uniTransfer(payable(msg.sender), amount);\\n    }\\n\\n    /**\\n     * @notice Allows the contract owner to set a new resolver threshold.\\n     * The resolver threshold is the minimum total supply percentage required to get into the whitelist.\\n     * @param resolverPercentageThreshold_ The new resolver threshold.\\n     */\\n    function setResolverPercentageThreshold(uint256 resolverPercentageThreshold_) external onlyOwner {\\n        _setResolverPercentageThreshold(resolverPercentageThreshold_);\\n    }\\n\\n\\n    /**\\n     * @notice Attempts to register the caller in the whitelist.\\n     * @dev Reverts if the caller's total supply percentage is below the resolver threshold.\\n     */\\n    function register() external {\\n        uint256 percentageThreshold = resolverPercentageThreshold;\\n        uint256 totalSupply = TOKEN.totalSupply();\\n        if (!_isValidBalance(percentageThreshold, TOKEN.balanceOf(msg.sender), totalSupply)) revert BalanceLessThanThreshold();\\n        if (!_whitelist.add(msg.sender)) revert AlreadyRegistered();\\n        emit Registered(msg.sender);\\n        _clean(percentageThreshold, totalSupply);\\n    }\\n\\n    /**\\n     * @notice Registers a worker for the resolver to settle orders.\\n     * @param chainId The chain ID where the worker will assigned.\\n     * @param promotee The worker's address.\\n     */\\n    function promote(uint256 chainId, address promotee) external {\\n        if (promotions[msg.sender][chainId] == promotee) revert SamePromotee();\\n        promotions[msg.sender][chainId] = promotee;\\n        emit Promotion(msg.sender, chainId, promotee);\\n    }\\n\\n    /**\\n     * @notice Cleans the whitelist by removing addresses that fall below the resolver threshold.\\n     */\\n    function clean() external {\\n        _clean(resolverPercentageThreshold, TOKEN.totalSupply());\\n    }\\n\\n    /**\\n     * @notice Returns the addresses in the whitelist.\\n     * @return whitelist A list of whitelisted addresses.\\n     */\\n    function getWhitelist() external view returns (address[] memory /* whitelist */) {\\n        return _whitelist.items.get();\\n    }\\n\\n    /**\\n     * @notice Returns the worker list for a particular chain ID.\\n     * @param chainId The chain ID to get the promoted addresses for.\\n     * @return promotees A list of worker addresses.\\n     */\\n    function getPromotees(uint256 chainId) external view returns (address[] memory promotees) {\\n        promotees = _whitelist.items.get();\\n        unchecked {\\n            uint256 len = promotees.length;\\n            for (uint256 i = 0; i < len; ++i) {\\n                promotees[i] = promotions[promotees[i]][chainId];\\n            }\\n        }\\n    }\\n\\n    function _setResolverPercentageThreshold(uint256 resolverPercentageThreshold_) private {\\n        if (resolverPercentageThreshold_ > BASIS_POINTS) revert InvalidThreshold();\\n        resolverPercentageThreshold = resolverPercentageThreshold_;\\n        emit ResolverPercentageThresholdSet(resolverPercentageThreshold_);\\n    }\\n\\n    function _removeFromWhitelist(address account) private {\\n        _whitelist.remove(account);\\n        emit Unregistered(account);\\n    }\\n\\n    function _isValidBalance(uint256 percentageThreshold, uint256 balance, uint256 totalSupply) private pure returns (bool) {\\n        return (\\n            balance > 0 &&\\n            balance * BASIS_POINTS >= totalSupply * percentageThreshold)\\n        ;\\n    }\\n\\n    /**\\n     * @dev Removes addresses from the whitelist that fall below the resolver threshold.\\n     * @param percentageThreshold The whitelist enforced minimal percentage of token's total suplly.\\n     * @param totalSupply The total supply of the token.\\n     */\\n    function _clean(uint256 percentageThreshold, uint256 totalSupply) private {\\n        uint256 whitelistLength = _whitelist.length();\\n        unchecked {\\n            for (uint256 i = 0; i < whitelistLength; ) {\\n                address curWhitelisted = _whitelist.at(i);\\n                uint256 balance = TOKEN.balanceOf(curWhitelisted);\\n                if (!_isValidBalance(percentageThreshold, balance, totalSupply)) {\\n                    _removeFromWhitelist(curWhitelisted);\\n                    whitelistLength--;\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x77f706476203273e41eca3236a91732a5146e1c02937421c9e27ce19d1d31560\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080346100c257601f610a3938819003918201601f19168301916001600160401b038311848410176100c6578084926020946040528339810103126100c257516001600160a01b0390818116908190036100c25733156100aa575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3600254161760025561095e90816100db8239f35b604051631e4fbdf760e01b81525f6004820152602490fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe608060409080825260049081361015610016575f80fd5b5f3560e01c9081632af051661461079a57508063715018a61461070057806378e3214f146104f05780638da5cb5b1461049f578063e5136e94146102ba578063ed95063814610268578063f204bdb91461015c5763f2fde38b14610078575f80fd5b346101585760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158576100af610806565b906100b86108d8565b73ffffffffffffffffffffffffffffffffffffffff8092169283156101295750505f54827fffffffffffffffffffffffff00000000000000000000000000000000000000008216175f55167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b905f60249251917f1e4fbdf7000000000000000000000000000000000000000000000000000000008352820152fd5b5f80fd5b503461015857817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158578035916024359173ffffffffffffffffffffffffffffffffffffffff808416809403610158578390335f526001602052835f20865f52602052835f20541614610241577fb863cf86b291171e4b0332ea12b59af030f98a2c74a6d51effaf1109ae4c7f1e6060858585335f526001602052805f20835f52602052805f20827fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790558051923384526020840152820152a1005b90517f53645587000000000000000000000000000000000000000000000000000000008152fd5b8234610158575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101585760209073ffffffffffffffffffffffffffffffffffffffff600254169051908152f35b503461015857602090817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101585780359273ffffffffffffffffffffffffffffffffffffffff93825f86600254168451928380927fd01f63f50000000000000000000000000000000000000000000000000000000082525afa938415610495575f946103cd575b50508293919351905f5b828110610393575050508251928180850191818652845180935285019301915f5b82811061037d5785850386f35b8351871685529381019392810192600101610370565b80876103a460019388999799610897565b51165f52818752845f20835f52875287855f2054166103c38288610897565b520194929461034f565b909193503d805f843e6103e08184610829565b820190858383031261015857825167ffffffffffffffff9384821161015857019082601f8301121561015857815193841161046957508260051b9084519361042a88840186610829565b84528680850192820101928311610158578601905b82821061045157505050915f80610345565b8151888116810361015857815290860190860161043f565b6041907f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b83513d5f823e3d90fd5b8234610158575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101585760209073ffffffffffffffffffffffffffffffffffffffff5f54169051908152f35b50903461015857807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015857813573ffffffffffffffffffffffffffffffffffffffff811690818103610158576024359161054d6108d8565b8261055457005b80159081156106e2575b50156106505750804710610629575f8080809333611388f13d15610624573d67ffffffffffffffff81116105f8578251906105c160207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160183610829565b81525f60203d92013e5b156105d257005b517fb12d13eb000000000000000000000000000000000000000000000000000000008152fd5b6041847f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b6105cb565b50517ff4d678b8000000000000000000000000000000000000000000000000000000008152fd5b905f60446020928551907fa9059cbb0000000000000000000000000000000000000000000000000000000082523388830152602482015282855af190816106c0575b501561069a57005b517ffb7f5079000000000000000000000000000000000000000000000000000000008152fd5b90503d156106da575060015f5114601f3d11165b5f610692565b3b15156106d4565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee9150145f61055e565b34610158575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158576107366108d8565b5f73ffffffffffffffffffffffffffffffffffffffff81547fffffffffffffffffffffffff000000000000000000000000000000000000000081168355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b83903461015857817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158576020916107d5610806565b9073ffffffffffffffffffffffffffffffffffffffff8092165f5260018452805f206024355f5284525f2054168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361015857565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761086a57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b80518210156108ab5760209160051b010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b73ffffffffffffffffffffffffffffffffffffffff5f541633036108f857565b60246040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152fdfea2646970667358221220f57101a0eea8ba167f884ab53e1d65c16c7c3ad328e2b390afd728c5f8ae303764736f6c63430008170033",
  "deployedBytecode": "0x608060409080825260049081361015610016575f80fd5b5f3560e01c9081632af051661461079a57508063715018a61461070057806378e3214f146104f05780638da5cb5b1461049f578063e5136e94146102ba578063ed95063814610268578063f204bdb91461015c5763f2fde38b14610078575f80fd5b346101585760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158576100af610806565b906100b86108d8565b73ffffffffffffffffffffffffffffffffffffffff8092169283156101295750505f54827fffffffffffffffffffffffff00000000000000000000000000000000000000008216175f55167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b905f60249251917f1e4fbdf7000000000000000000000000000000000000000000000000000000008352820152fd5b5f80fd5b503461015857817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158578035916024359173ffffffffffffffffffffffffffffffffffffffff808416809403610158578390335f526001602052835f20865f52602052835f20541614610241577fb863cf86b291171e4b0332ea12b59af030f98a2c74a6d51effaf1109ae4c7f1e6060858585335f526001602052805f20835f52602052805f20827fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790558051923384526020840152820152a1005b90517f53645587000000000000000000000000000000000000000000000000000000008152fd5b8234610158575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101585760209073ffffffffffffffffffffffffffffffffffffffff600254169051908152f35b503461015857602090817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101585780359273ffffffffffffffffffffffffffffffffffffffff93825f86600254168451928380927fd01f63f50000000000000000000000000000000000000000000000000000000082525afa938415610495575f946103cd575b50508293919351905f5b828110610393575050508251928180850191818652845180935285019301915f5b82811061037d5785850386f35b8351871685529381019392810192600101610370565b80876103a460019388999799610897565b51165f52818752845f20835f52875287855f2054166103c38288610897565b520194929461034f565b909193503d805f843e6103e08184610829565b820190858383031261015857825167ffffffffffffffff9384821161015857019082601f8301121561015857815193841161046957508260051b9084519361042a88840186610829565b84528680850192820101928311610158578601905b82821061045157505050915f80610345565b8151888116810361015857815290860190860161043f565b6041907f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b83513d5f823e3d90fd5b8234610158575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101585760209073ffffffffffffffffffffffffffffffffffffffff5f54169051908152f35b50903461015857807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015857813573ffffffffffffffffffffffffffffffffffffffff811690818103610158576024359161054d6108d8565b8261055457005b80159081156106e2575b50156106505750804710610629575f8080809333611388f13d15610624573d67ffffffffffffffff81116105f8578251906105c160207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160183610829565b81525f60203d92013e5b156105d257005b517fb12d13eb000000000000000000000000000000000000000000000000000000008152fd5b6041847f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b6105cb565b50517ff4d678b8000000000000000000000000000000000000000000000000000000008152fd5b905f60446020928551907fa9059cbb0000000000000000000000000000000000000000000000000000000082523388830152602482015282855af190816106c0575b501561069a57005b517ffb7f5079000000000000000000000000000000000000000000000000000000008152fd5b90503d156106da575060015f5114601f3d11165b5f610692565b3b15156106d4565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee9150145f61055e565b34610158575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158576107366108d8565b5f73ffffffffffffffffffffffffffffffffffffffff81547fffffffffffffffffffffffff000000000000000000000000000000000000000081168355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a3005b83903461015857817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610158576020916107d5610806565b9073ffffffffffffffffffffffffffffffffffffffff8092165f5260018452805f206024355f5284525f2054168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361015857565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761086a57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b80518210156108ab5760209160051b010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b73ffffffffffffffffffffffffffffffffffffffff5f541633036108f857565b60246040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152fdfea2646970667358221220f57101a0eea8ba167f884ab53e1d65c16c7c3ad328e2b390afd728c5f8ae303764736f6c63430008170033",
  "devdoc": {
    "errors": {
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "getPromotees(uint256)": {
        "params": {
          "chainId": "The chain ID to get the promoted addresses for."
        },
        "returns": {
          "promotees": "A list of worker addresses."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "promote(uint256,address)": {
        "params": {
          "chainId": "The chain ID where the worker will assigned.",
          "promotee": "The worker's address."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "rescueFunds(address,uint256)": {
        "params": {
          "amount": "The amount of tokens to recover.",
          "token_": "The token to recover."
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "CrosschainWhitelistRegistry",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Promotion(address,uint256,address)": {
        "notice": "Emitted when a new worker for a resolver is set."
      }
    },
    "kind": "user",
    "methods": {
      "getPromotees(uint256)": {
        "notice": "Returns the worker list for a particular chain ID."
      },
      "promote(uint256,address)": {
        "notice": "Registers a worker for the resolver to settle orders."
      },
      "rescueFunds(address,uint256)": {
        "notice": "Allows the contract owner to recover any tokens accidentally sent to the contract."
      }
    },
    "notice": "The contract manages a promotees for crosschain resolvers. It also includes an emergency rescue function for tokens sent to the contract accidentally.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3050,
        "contract": "contracts/CrosschainWhitelistRegistry.sol:CrosschainWhitelistRegistry",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 6195,
        "contract": "contracts/CrosschainWhitelistRegistry.sol:CrosschainWhitelistRegistry",
        "label": "promotions",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_address))"
      },
      {
        "astId": 6198,
        "contract": "contracts/CrosschainWhitelistRegistry.sol:CrosschainWhitelistRegistry",
        "label": "whitelistRegistry",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(WhitelistRegistry)7716"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(WhitelistRegistry)7716": {
        "encoding": "inplace",
        "label": "contract WhitelistRegistry",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_address)"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}